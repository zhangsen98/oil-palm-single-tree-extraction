L = L.astype(np.uint8)
print("Step One")
step1 = L.copy()
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (A, A))  # Structuring element size
TOP = cv2.morphologyEx(step1, cv2.MORPH_TOPHAT, kernel, B)
# TOP_path = os.path.join(fileoutdir, "TOP_" + (basename) + ".tif")
# array_to_raster2(TOP_path, TOP, crs, transform, 0)

retB, thresh = cv2.threshold(TOP[TOP > 0], C, D, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

threshB = TOP.copy()
splitB = retB
threshB[TOP < splitB] = E
threshB[TOP >= splitB] = F
# TOPotsu_path = os.path.join(fileoutdir, "TOPotsu_" + (basename) + ".tif")
# array_to_raster2(TOPotsu_path, threshB, crs, transform, 0)

hang = threshB.shape[0]
lie = threshB.shape[1]

# Window size for large window
S = G
# Row count
X = H
# Column count
Y = I
# Step size
step = J
sum_big = K
sum_small = L
# Window size for small window
P = M
P2 = N

big = threshB.copy()
big[big == E] = F
small = threshB.copy()
small[small == E] = F
big = big.astype(np.float64)
small = small.astype(np.float64)

for X in range(0, hang - G, step):
    for Y in range(0, lie - G, step):
        window_big = threshB[X:X + S, Y:Y + S]
        sum_big = np.sum(window_big)
        window_small = threshB[X + P2:X + P2 + P, Y + P2:Y + P2 + P]
        sum_small = np.sum(window_small)
        big[X + O:X + P, Y + O:Y + P] = sum_big / PQ
        small[X + O:X + P, Y + O:Y + P] = sum_small / QR

small[big > small] = E
small[small < U] = E
# big[small < V] = E
# big[big < W] = E
small[small > E] = X
small = small.astype(np.uint8)
# small_path = os.path.join(fileoutdir, "R" + str(U) + "_" + (basename) + ".tif")
# array_to_raster2(small_path, small, crs, transform, 0)

print("Step Two")
# Area is in square meters
max_area = Y
min_area = Z
# Set the minimum area, areas smaller than this will be removed during the first iteration
max_area2 = A1
# Pixel value for trees in raster
raster_tree_num = B1
# Number of iterations
iteration_num = C1

image = small.copy()

gdfs = []
# Raster to vector conversion
gdf = array_to_gdf(image, raster_tree_num, crs, transform)
gdf["area"] = gdf.area.to_numpy() * 1.0e10
# Remove vectors with area less than the set minimum area
gdf = gdf.loc[gdf['area'] > max_area2]
if not gdf.size:
    print(f'All vector areas are smaller than {max_area2}')
    sys.exit()

# Extract based on area
gdfs.append(gdf.loc[(gdf["area"] <= max_area) & (gdf["area"] >= min_area)])
gdf = gdf.loc[(gdf["area"] > max_area) | (gdf["area"] < min_area)]
if not gdf.size:
    print(f"All vector areas are within the range of {min_area} and {max_area}")

# Vector to raster conversion
image = gdf_to_array(gdf, image, transform, raster_tree_num)

for i in range(iteration_num):
    print(f"Iteration {i + 1}")
    # Erosion
    kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (B2, B2))
    image = cv2.erode(image, kernel)
    mask = image == raster_tree_num
    if not np.any(mask):
        break
    # Raster to vector conversion
    gdf = array_to_gdf(image, raster_tree_num, crs, transform)

    if not gdf.size:
        break
    gdf["area"] = gdf.area.to_numpy() * 1.0e10

    # Extract based on area
    gdfs.append(gdf.loc[(gdf["area"] <= max_area) & (gdf["area"] >= min_area)])
    gdf = gdf.loc[(gdf["area"] > max_area) | (gdf["area"] < min_area)]
    if not gdf.size:
        break

    # Vector to raster conversion
    image = gdf_to_array(gdf, image, transform, raster_tree_num)
